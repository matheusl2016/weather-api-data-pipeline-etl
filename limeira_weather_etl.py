# -*- coding: utf-8 -*-
"""limeira_weather_etl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yk0hHFiIFexxZ5lPUofWFQugTiytAVr6

# Criando as pastas de dados
"""

!mkdir -p data/raw data/processed

#instalando as depend√™ncias pra garantir que tudo esteja atualizado

!pip install requests pandas python-dotenv

## pastas criadas, assim como as bibliotecas que irei usar

"""## Configurando minha API Key (vou usar o site WeatherAPI)"""

import requests

# minha API Key do site
API_KEY = "32f022fb09a44eaaaa6142120252210"

# Cidade escolhida
city = "Limeira"

# URL em portugu√™s
url = f"http://api.weatherapi.com/v1/current.json?key={API_KEY}&q={city}&lang=pt"

# Fazendo a requisi√ß√£o
response = requests.get(url)
data = response.json()

# Exibindo o resultado bruto:
print("Resposta da API:")
print(data)

# Extraindo informa√ß√µes √∫teis
print("\n--- Dados formatados ---")
print(f"Local: {data['location']['name']}, {data['location']['region']}, {data['location']['country']}")
print(f"Temperatura: {data['current']['temp_c']}¬∞C")
print(f"Condi√ß√£o: {data['current']['condition']['text']}")
print(f"Umidade: {data['current']['humidity']}%")
print(f"Vento: {data['current']['wind_kph']} km/h")

"""# Estrutura inicial - confirmando se as pastas j√° existem"""

import os

# Cria√ß√£o das pastas para organiza√ß√£o
os.makedirs("data/raw", exist_ok=True)
os.makedirs("data/processed", exist_ok=True)

print("Estrutura de pastas criada com sucesso!")

"""## Podemos seguir com a etapa de extra√ß√£o dos dados da WeatherAPI:"""

# ETAPA 2 - EXTRA√á√ÉO E TRANSFORMA√á√ÉO DE DADOS DA WEATHERAPI


import os
import requests
import pandas as pd
from datetime import datetime

# Configura√ß√µes iniciais
API_KEY = "32f022fb09a44eaaaa6142120252210"  # minha chave da WeatherAPI
CITY = "Limeira"
LANG = "pt"

# URL de requisi√ß√£o
url = f"http://api.weatherapi.com/v1/current.json?key={API_KEY}&q={CITY}&lang={LANG}"

# Fazendo a requisi√ß√£o
response = requests.get(url)

if response.status_code == 200:
    data = response.json()
    print("‚úÖ Requisi√ß√£o bem-sucedida!")
else:
    print(f"‚ùå Erro na requisi√ß√£o: {response.status_code}")
    print(response.text)
    raise SystemExit()

# Salvando os dados brutos (JSON original)
raw_path = "data/raw/weather_raw.json"

with open(raw_path, "w", encoding="utf-8") as f:
    import json
    json.dump(data, f, ensure_ascii=False, indent=4)

print(f"Dados brutos salvos em: {raw_path}")

# Processando informa√ß√µes √∫teis
processed_data = {
    "cidade": data["location"]["name"],
    "regiao": data["location"]["region"],
    "pais": data["location"]["country"],
    "temperatura_C": data["current"]["temp_c"],
    "condicao": data["current"]["condition"]["text"],
    "umidade_%": data["current"]["humidity"],
    "vento_kph": data["current"]["wind_kph"],
    "ultima_atualizacao": data["current"]["last_updated"],
    "data_extracao": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
}

# Convertendo para DataFrame
df = pd.DataFrame([processed_data])

# Salvando dados processados
processed_path = "data/processed/weather_processed.csv"
df.to_csv(processed_path, index=False, encoding="utf-8")

print(f"‚úÖ Dados processados salvos em: {processed_path}")

# Exibindo visualmente
print("\nüìä Pr√©via dos dados processados:")
print(df)

"""# vamos fazer a Carga (Load)

## vamos carregar o df tratado dentro de um banco de dados SQLite, para simular o pipeline completo de ETL
"""

# ETAPA 3 - CARGA DOS DADOS (LOAD)
## Aqui vamos salvar os dados processados no banco de dados SQLite
## Isso simula a etapa "L" (Load) do pipeline ETL completo

import sqlite3

# 1Ô∏è- Vamos criar/abrir um banco de dados local dentro da pasta data/
conn = sqlite3.connect("data/weather_data.db")

# 2Ô∏è- Envia o DataFrame "df" criado na etapa de transforma√ß√£o
#     para dentro de uma tabela chamada "clima_limeira"
#     if_exists="append" garante que novos dados s√£o adicionados sem apagar os antigos
df.to_sql("clima_limeira", conn, if_exists="append", index=False)

# 3Ô∏è- Fecha a conex√£o com o banco
conn.close()

print("Dados carregados no banco SQLite com sucesso!")

"""# Vamos inspecionar o nosso banco de dados p ver se os dados foram gravados corretamente

"""

conn = sqlite3.connect("data/weather_data.db")
df_hist = pd.read_sql("SELECT * FROM clima_limeira", conn)
conn.close()

print("üìä Hist√≥rico de coletas gravadas no banco:")
print(df_hist.tail())

"""# Visualiza√ß√£o (Gr√°fico da Temperatura)
## este bloco ir√° gerar automaticamente um gr√°fico da varia√ß√£o de temperatura usando os dados salvos no banco SQLite
"""

# Mostra o hist√≥rico de temperaturas ao longo das coletas

import matplotlib.pyplot as plt

# 1- L√™ os dados do banco
conn = sqlite3.connect("data/weather_data.db")
df_hist = pd.read_sql("SELECT * FROM clima_limeira", conn)
conn.close()

# 2Ô∏è- Gera o gr√°fico
plt.figure(figsize=(10, 5))
plt.plot(df_hist["data_extracao"], df_hist["temperatura_C"], marker="o", linewidth=2)
plt.title("Hist√≥rico de Temperatura - Limeira/SP")
plt.xlabel("Data de Extra√ß√£o")
plt.ylabel("Temperatura (¬∞C)")
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

# 3Ô∏è- Salva a imagem na pasta processed
grafico_path = "data/processed/grafico_temperatura.png"
plt.savefig(grafico_path)
plt.show()

print(f"Gr√°fico salvo em: {grafico_path}")

"""### O gr√°fico acima mostra o hist√≥rico de temperatura da cidade de Limeira/SP com base nas coletas armazenadas no banco de dados local (weather_data.db).

No entanto, como o projeto foi executado apenas uma vez at√© o momento, o sistema possui somente uma coleta registrada, resultando em um √∫nico ponto no gr√°fico.

Isso √© esperado, pois a aplica√ß√£o foi desenvolvida para registrar dados de temperatura em tempo real a cada execu√ß√£o do script.
Em um cen√°rio de produ√ß√£o, o script seria agendado para rodar de forma autom√°tica (por exemplo, de hora em hora), alimentando continuamente o banco de dados com novas medi√ß√µes.

Dessa forma, ao longo do tempo, o gr√°fico passaria a representar a varia√ß√£o real da temperatura em diferentes momentos do dia ‚Äî permitindo an√°lises como:

- Tend√™ncia de aumento ou queda de temperatura;

- Compara√ß√£o entre dias ou hor√°rios;

- Identifica√ß√£o de padr√µes clim√°ticos locais.

Em uma pr√≥xima vers√£o do projeto, √© poss√≠vel:

- Agendar coletas autom√°ticas usando bibliotecas como schedule ou cron;

- Expandir o hist√≥rico utilizando o endpoint de hist√≥rico da WeatherAPI (history.json), para obter dados dos √∫ltimos dias;

Incluir previs√µes futuras, criando gr√°ficos comparativos entre valores reais e previstos.

Essa evolu√ß√£o transformaria o projeto de um simples extrator de dados clim√°ticos em um pipeline anal√≠tico completo, capaz de gerar insights sobre o comportamento do clima em Limeira ao longo do tempo.
"""

